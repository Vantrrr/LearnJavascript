'use strict';

"use strict";
class BatchableMesh {
  constructor() {
    this.batcher = null;
    this.batch = null;
    this.roundPixels = 0;
  }
  get blendMode() {
    return this.mesh.groupBlendMode;
  }
  reset() {
    this.mesh = null;
    this.texture = null;
    this.batcher = null;
    this.batch = null;
  }
  packIndex(indexBuffer, index, indicesOffset) {
    const indices = this.geometry.indices;
    for (let i = 0; i < indices.length; i++) {
      indexBuffer[index++] = indices[i] + indicesOffset;
    }
  }
  packAttributes(float32View, uint32View, index, textureId) {
    const mesh = this.mesh;
    const geometry = this.geometry;
    const wt = mesh.groupTransform;
    const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;
    const a = wt.a;
    const b = wt.b;
    const c = wt.c;
    const d = wt.d;
    const tx = wt.tx;
    const ty = wt.ty;
    const positions = geometry.positions;
    const uvs = geometry.uvs;
    const abgr = mesh.groupColorAlpha;
    for (let i = 0; i < positions.length; i += 2) {
      const x = positions[i];
      const y = positions[i + 1];
      float32View[index] = a * x + c * y + tx;
      float32View[index + 1] = b * x + d * y + ty;
      float32View[index + 2] = uvs[i];
      float32View[index + 3] = uvs[i + 1];
      uint32View[index + 4] = abgr;
      uint32View[index + 5] = textureIdAndRound;
      index += 6;
    }
  }
  get vertexSize() {
    return this.geometry.positions.length / 2;
  }
  get indexSize() {
    return this.geometry.indices.length;
  }
}

exports.BatchableMesh = BatchableMesh;
//# sourceMappingURL=BatchableMesh.js.map
